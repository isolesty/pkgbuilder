#! /bin/bash

configPbuilder() {
    local pbuilderrc=$1
    # Should I use options instead of configuration?
    info "Initialize pbuilder configuration"

    # Always overwrite the configuration
    cat <<EOF > $pbuilderrc
AUTO_DEBSIGN=no
ARCHITECTURE="${ARCH}"
BINDMOUNT="$WORKBASE"
ALLOWUNTRUSTED=yes
DEBOOTSTRAPOPTS=( '--variant=buildd' '--no-check-gpg' )
EXTRAPACKAGES="lintian eatmydata"
MIRRORSITE="${MIRRORSITE[${ARCH}]}"
OTHERMIRROR="${OTHERMIRROR[${ARCH}]}"
# pbuilder >= 0.225
# EATMYDATA=yes
export LD_PRELOAD="${LD_PRELOAD:+$LD_PRELOAD:}libeatmydata.so"
EOF
}

initializePbuilder() {
    hasBin pbuilder   || die "Install pbuilder!!!"
    hasBin cowbuilder || die "Install cowbuilder!!!"

    createdir ${WORKBASE}/deepin-chroot

    sudo cowbuilder --create	 \
         ${PBUILDEROPTS[@]}	 \
         ${PBUILDEREXTRAOPTS[@]} \
         ${COWBUILDEROPTS[@]}
}

configGitReview() {
    echo "create per project gitreview configuration"
    if [[ ! -f .gitreview ]] ; then
        cat <<EOF > .gitreview
[gerrit]
defaultremote = origin
EOF
    fi
}

downloadGerritChange() {
    if hasBin git-review ; then
        git review -d $1
    else
        die "Missing git-review in the system!!!"
    fi
}

# download debian src
downloadDebianSrcFromUpstream() {
    local aptcache=
    local aptdir=${scriptdir}/apt

    local apt_options="-o Dir::Etc=${aptdir} \
          -o Dir::Etc::sourcelist=sources.list-${ARCH} \
	  -o Dir::Etc::SourceParts=/dev/null \
	  -o Dir::State=${aptdir}/state \
	  -o Dir::Cache=${aptdir}/cache \
	  -o Debug::NoLocking=true \
	  -o Acuqire::Retries=5 \
	  -o APT::Architecture=${ARCH} \
	  -o APT::Default-Release=${DISTRIBUTIONS[${ARCH}]} \
	  -o APT::Get::Assume-Yes=true \
	  -o APT::Get::AllowUnauthenticated=true"

    mkdir -pv ${aptdir}/state/lists/partial

    # create sources.list
    cat <<EOF > ${aptdir}/sources.list-${ARCH}
deb [lang=en] ${UPSTREAMREPO[$ARCH]} ${DISTRIBUTIONS[${ARCH}]} main contrib non-free
deb-src [lang=en] ${UPSTREAMREPO[$ARCH]} ${DISTRIBUTIONS[${ARCH}]} main contrib non-free
EOF
    # update package index
    apt-get ${apt_options} update

    aptcache=$(apt-cache ${apt_options} showsrc $package)
    # get package name and package version
    package=$(echo "${aptcache}" | awk '/^Package:/ {print $2; exit}')
    PKGVER=$(echo "${aptcache}" | awk -F: '/^Version:/ {gsub(/ /, "", $NF); ver=$NF} END {print ver}')

    # download debian source code
    createWorkdir
    pushd ${workdir}
    apt-get ${apt_options} source --download-only ${package}
    popd
}

downloadDebianSrc() {
    local odscfile=$(basename ${dscurl})
    local dscfile=$(urlDecode $odscfile)

    package=${dscfile%%_*}
    PKGVER=$(echo ${dscfile//.dsc} | sed -e "s/${package}_//")

    createWorkdir

    if checkValidURL $dscurl ; then
        hasBin dget || die "Missing devscripts in the system"
        pushd ${workdir}
        dget -d -u ${dscurl}
        # rename dscfile
        [[ $odscfile == $dscfile ]] || mv $odscfile $dscfile
        popd
    fi

    [[ -f ${workdir}/${dscfile} ]] || \
        die "Not able to find ${dscfile} in ${workdir}"
    dscurl=$dscfile
}

createSrcArchives() {
    createWorkdir

    local work_branch=${CHECKOUT_BRANCH[${package}]:-master}
    local repodir=${REPOBASE}/${package}

    info "Current branch is $work_branch"

    if [[ -n $targetbranch ]] ; then
        work_branch=$targetbranch
        warn "Set branch to $targetbranch, according to command line options"
    fi

    hasBin git || die "Missing git in the system!!!"

    if [[ -d ${repodir}/.git ]] ; then
        # set origin url
        pushd ${repodir}
        git remote -v set-url origin ${repository}
        popd
    else
        # clone git repository
        git clone -b ${work_branch} ${repository} ${repodir}
    fi

    pushd ${repodir}

    # in case we need to switch branches
    git checkout -B ${work_branch} --track origin/${work_branch}
    git pull origin ${work_branch}

    local commit_id=$(git rev-parse HEAD | cut -b 1-6)
    assert commit_id
    local tag=$(git describe --tags --abbrev=0)
    local revision=$(git log ${tag}..origin/${work_branch} --oneline | wc -l)
    assert revision

    if [[ -z ${tag} ]] ;then
        info "tag fallback to 0.1"
        tag=0.1
    fi
    assert tag

    # gerrit CL workflow
    if [[ ${CHANGELIST} -gt 1 ]] ; then
        configGitReview
        downloadGerritChange $CHANGELIST
        PKGVER=$tag+cl~$CHANGELIST
    else
        PKGVER=$tag+r${revision}~${commit_id}
    fi

    info "Create ${package} upstream source tarball..."
    git archive --format=tar --prefix=${package}-${PKGVER}/ HEAD | \
        xz -z > ${workdir}/${package}_${PKGVER}.orig.tar.xz

    popd
}

prepareBuild() {
    local srcdir=${workdir}/${package}-${PKGVER}
    local srcpkg=${workdir}/${package}_${PKGVER}.orig.tar.xz

    rm -rf $srcdir

    if [[ -n $dscurl ]] ; then
        dpkg-source -x ${workdir}/${dscurl} ${srcdir}
    elif [[ -f ${workdir}/${package}_${PKGVER}.dsc ]] ; then
        dpkg-source -x ${workdir}/${package}_${PKGVER}.dsc ${srcdir}
    else
        if [[ ! -f $srcpkg ]] ; then
            srcpkg=${srcpkg/.orig/}
            [[ -f $srcpkg ]] || die "src package $srcpkg not found"
        fi

        tar xf ${srcpkg} -C ${workdir}

        pushd ${srcdir}
        if ! pkgIsDebianized ; then
            cp -a ${WORKBASE}/pkg_debian/${package}/debian .
        fi
        popd
    fi
}

createPbuilderChroot() {
    if [[ ${usepbuilder} -eq 1 ]] ; then
        configPbuilder ${scriptdir}/pbuilderrc
        hasPackage eatmydata  ||   \
            die "Please install eatmydata on the build host!!!"
        hasPbuilderChroot || initializePbuilder
    fi
}

fixArch() {
    local autotools_files=(
        /usr/share/misc/config.guess
        /usr/share/misc/config.sub
    )

    if [[ ${ARCH} == 'sw_64' ]] ; then
        if [[ -f config.guess && -f config.sub ]] ; then
            for src in ${autotools_files[@]}; do
                local dest=${src##*/}
                info "Replace architecture detection code in ${dest}"
                cp ${src} ${dest} -v
            done
        fi
    fi
}

buildPackage() {
    # override default dpkg-buildpackage options
    DBPKGOPTS+=" $@"
    pushd ${workdir}/${package}-${PKGVER}

    # Apply patches unless build official package (Not from any CL)
    [[ $CHANGELIST -eq 0 ]] && applyPatches

    # Special tweaks for architectures which has no native golang package
    if [[ ${CGO_ARCHS[@]} =~ "${ARCH} " ]] ; then
        fixBuildDeps
        fixDebuildOptions
    fi

    fixArch

    if [[ $do_build -eq 1 ]] ; then
        if [[ ${DEEPIN_PACKAGES} =~ " ${package} " ]] ; then
	        dch -v ${PKGVER} -D ${DISTRIBUTIONS[$ARCH]} "${changelog}"
        else
            dch -a -D ${DISTRIBUTIONS[$ARCH]} "${changelog}"
        fi

        if [[ $usepbuilder -eq 1 ]] ; then
            export BOPTS=${BOPTS//-e}
            warn "Set BOPTS to ${BOPTS:-NULL}"

            if [[ ${ARCH} == mipsel ]] ; then
                warn "${ARCH} Set environment to make package build against gccgo"
                export USE_CGO=1 CGO_ENABLED=1
            fi

            eval pdebuild --pbuilder cowbuilder \
                --use-pdebuild-internal         \
                --debbuildopts '"${DBPKGOPTS}"' \
                ${PBUILDEREXTRAOPTS[@]}         \
                --                              \
                ${PBUILDEROPTS[@]}              \
                ${COWBUILDEROPTS[@]}
        else
            info "Checking build dependencies:"
            dpkg-checkbuilddeps -a ${ARCH} debian/control

            info "Debuild options: ${BOPTS} ${DBPKGOPTS}"
            eval debuild ${BOPTS} ${DBPKGOPTS}
        fi
    fi
    popd
}

uploadArtifacts() {
    [[ -z $uhost ]] && return 0
    hasBin dput || die "Missing dput in the system!!!"
    dput -uf ${uhost} $(ls -At ${workdir}/*.changes| head -n 1)
}
